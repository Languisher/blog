---
title: "Cache Lab 1 前置知识"
description: "本文主要介绍计算机内存的结构，参考 CS:APP 6.2-6.3 部分内容。"
date: 2024-08-06
tags: ["CS:APP"]
---

本文主要介绍计算机内存的结构，参考 CS:APP 6.2-6.3 部分内容。

## 局部性

首先，我们先入为主地提出 **局部性 (locality)** 的概念：计算机程序倾向于引用 _临近_ 与其它最近引用过的数据项的数据项，或是 _最近_ 引用过的数据项本身。两种方式分别对应两种局部性的概念：**空间局部性 (spatial locality)** 和 **时间局部性 (temporal locality)**.

![](https://pub-f4fb14aad5ef4ee6a83bd71292941254.r2.dev/%E6%97%B6%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7%E5%92%8C%E7%A9%BA%E9%97%B4%E5%B1%80%E9%83%A8%E6%80%A7.drawio.png)

如图所示，也根据其定义非常好理解，空间局部性意味着如果一个内存位置被引用了一次，那么程序很有可能在不远处的将来来引用附近的一个内存位置；时间局部性意味着被引用过一次的内存位置很可能在不远的将来被多次引用。

一般来说，_有良好局部性的程序相比局部性差的程序运行更快_。局部性也是层次结构核心理念的体现，也会在后文中看到。

程序是否具有良好局部性可以直接快速通过定性分析得到，且结论都非常直观，主要体现在：重复引用相同变量的程序有较好的时间局部性（在这点上，全局变量由于其存储位置不一定在寄存器内因此不可预期而应该被避免）；对于具有定步长（如数列引用）的引用模式程序，布长越小，空间局部性越好；在较小的指令循环中，取指令过程具有较好时间和空间局部性。[^1]

## 层次结构

有没有既便宜、又能高速传输数据、还能存储海量数据的存储器呢？很遗憾现在技术不能实现。作为替代方法，提出了 **存储器层次结构 (memory hierarchy)** 的概念。一张经典的层次结构图如下所示，其中越上层的存储设备越小、越快然而成本越高，越底层的则正好与之相反。

![](https://pub-f4fb14aad5ef4ee6a83bd71292941254.r2.dev/202408062158551.png)


层次之间的数据是怎么移动的？想象一下你从家里到学校上课的过程，你只能把你要用到的一部分而不是你所有的个人物品带到学校里，这个想法正好就是层次结构的核心以及高速缓存的设计理念。

### 缓存与存储器层次结构的核心思想

**高速缓存 (Cache)** 是一个小而快速的存储设备，它是更大、也更慢的设备中的数据对象中的缓存区域。存储器层次结构的核心思想就是利用缓存，对于所有 k，_位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存_。这里的缓存有两层含义：
1. 从数据看，是 k+1 层的数据的一部分（准确的讲，应该称之为其完全相同的复制）
2. 从位置看，它被放在第 k 层

![](https://pub-f4fb14aad5ef4ee6a83bd71292941254.r2.dev/202408062204392.png)

为了精确描述，以下提出几个名词：
- **块 (block)**：第 k+1 层数据被划分成很多具有各自唯一地址或名字的块；相对应的，第 k 层也被划分成很多块，但是数量相比于其底层更少。
- **传送单元 (transfer unit)**：即中间的一块，用于数据在两层之间来回复制。

随着与 CPU 距离的增长（即越底层的部分），数据传输时间大大增长，因此对应的传送单元会使用更大的块。

对于任意一层（命名为 k）来说，因为该层缓存是 k+1 层数据的子集，所以当需要 k+1 层数据（命名为 d）的时候，根据 d 是否存在在第 k 层会出现两种情况：
- **缓存命中 (cache hit)**：d 存储在该层缓存中，直接读取数据远远快于读取 k+1 层数据
- **缓存不命中 (cache miss)**：正好相反，d 没有存储在该层缓存中。

当发生缓存不命中时，就需要从 k+1 层（事实上，根据存储器的层次结构，是 k+1 层的缓存）中取出 d，即取出 d 所在的块。与之同时产生一个问题，第 k 层缓存数量是固定的，必然会覆盖一个现存的块，称之为 **替换 (replacing)** 或 **驱逐 (evicting)**，被覆盖的块被称之为 **牺牲块 (victim block)**.

怎么覆盖通常是由缓存的 **替换策略 (replacement policy)** 决定，通常使用的是 **最近最少被使用 (LRU)** 策略。

具体而言，不命中中有几种特殊的种类：
- **冷不命中 (cold miss)**，指程序刚启动，缓存仍然为空需要通过 **放置策略 (placement policy)** 取出这个块，这个事件短暂且不会在稳定后出现。
- **冲突不命中 (conflict miss)**，指不好的映射策略导致缓存持续的不命中。例如，采用 mod4 的映射策略会使 0, 8, 0, 8 的请求一来访问同一个缓存块，而来两个对象又同时映射到同一个缓存块。

[^1]:详见书本 P418-419